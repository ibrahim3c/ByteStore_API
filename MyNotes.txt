# ByteStore – Backend Project Documentation

**Stack:** ASP.NET Core 8 Web API, EF Core 8, PostgreSQL, Redis, Serilog, FluentValidation, Identity + JWT, Stripe (payments), .

**Architecture:** Onion Architecture (Domain-centric). No CQRS. Service + Repository + Unit of Work. Controllers with Endpoint grouping.

**Repo layout (monorepo):**

```
/ByteStore
  /src
    /Core
      /Domain
        /Entities
        /Repositories
      /Application
        /Services
        /DTOs
        /Validators
        /Mappings
        /Exceptions
        DependencyInjection.cs
      /External
        /Api (ASP.NET Core host)
          /Controllers
          /Extensions (DI, Auth, Swagger, HealthChecks)
          appsettings.json
          Program.cs
          secret.json
        /Persistence (Infrastructure)
          /Database (DbContext, Configurations)
          /Migrations
          /Repositories
          /Seeders
          /Integration (Payment, Email)
          DependencyInjection.cs
  /deploy
    docker-compose.yml
  /docs
    ERD.png / API.postman_collection.json
```

---

## 1) Executive Summary

ByteStore backend is a modular eCommerce API with a clean domain model, split by concerns using Onion Architecture. The API exposes resources for catalog (products, categories, brands), customer (accounts, addresses, wishlists), shopping flow (cart, orders, payments, shipments), and admin (inventory, pricing, promotions).

---

## 2) Goals & Non‑Functional Requirements

* **Scalability:** stateless API, cache-heavy (Redis), DB connection pooling, async I/O.
* **Security:** JWT, refresh tokens, HTTPS, role-based + policy-based authorization (Customer, Admin), data validation and rate limiting.
* **Reliability:** health checks, retries, idempotency keys on payments.
* **Observability:** structured logging (Serilog), request tracing, metrics, audit logs.
* **Performance:** pagination, filtering, sorting; EF compiled queries; output caching for catalog.
* **Maintainability:** SOLID, repository/specification pattern, fluent validation, unit/integration tests.
* **Portability:** Dockerized, environment-driven configuration.

---

## 3) Onion Architecture Overview

* **Domain (Core):** business rules, entities, enums, repository interfaces. No external dependencies.
* **Application (Core):** use-case orchestration via services. Defines DTOs, mappings, and validation. Depends only on Domain.
* **Infrastructure (External → Persistence):** EF Core DbContext, repository implementations, integrations (Stripe, SendGrid, storage), Redis cache providers. Depends on Core.
* **API (External → Api):** composition root. Configures DI, middleware, endpoints, Swagger, auth, health checks.

**Request flow:** `Api Endpoint → Application Service → Domain Entities (via Repositories & UnitOfWork) → DbContext`. Cross-cutting: logging, validation, caching.

---

## 4) Domain Model

**Key Entities**

    Address – id,street, city, state, postalCode, country, isPrimary, addressType, userId → (FK to Customer).
    Brand – id, name, description, logoUrl, products (list of Product).
    CartItem – id, quantity, shoppingCartId (FK), productId (FK), shoppingCart (ref), product (ref).
    Category – id, name, description, imageUrl, parentCategoryId (nullable), parentCategory (ref), subCategories (list of Category), products (list of Product).
    Customer – firstName, lastName, dateOfBirth, orders (list of Order), addresses (list of Address), shoppingCart (ref), reviews (list of ProductReview).
    Order – orderDate, totalAmount, status (Pending, Processing, Shipped, Delivered, Cancelled), userId, shippingAddressId, billingAddressId, user (ref Customer), shippingAddress (ref Address), billingAddress (ref Address), orderItems (list of OrderItem).
    OrderItem – id, quantity, unitPrice, orderId, productId, order (ref Order), product (ref Product).
    Product – id, name, description, price, stockQuantity, isActive, createdAt, updatedAt, categoryId, brandId, category (ref Category), brand (ref Brand), specifications (list of ProductSpecification), orderItems (list of OrderItem), cartItems (list of CartItem), reviews (list of ProductReview), images (list of ProductImage).
    ProductImage – id, imageUrl, isPrimary, title, productId, product (ref Product).
    ProductReview – id, title, content, rating, createdOn, productId, userId, product (ref Product), customer (ref Customer).
    ProductSpecification – id, key, value, productId, product (ref Product).
    ShoppingCart – id, createdAt, updatedAt, customerId, customer (ref Customer), cartItems (list of CartItem).
    AppRole
    AppUser



**Aggregates**

* Product, Order, Cart.

**Invariants & Rules Examples**

* Cannot add to cart if `stockQuantity < requestedQty`.
* Order totals = Σ(items) − discounts + shipping + tax.
* Review allowed only if customer purchased the product.

---

## 5) Persistence & Data Modeling

**EF Core** with Fluent configurations.

* Soft-delete via `IsDeleted` + global query filters.
* Decimal precision for Money fields.
* Indexes: `Product(categoryId, brandId)`, `Order(orderNo)`.

**Unit of Work**

* `IUnitOfWork` with `SaveChangesAsync()` wrapping DbContext transaction.

**Repositories**

* `IProductRepository`, `ICartRepository`, `IOrderRepository`, `ICustomerRepository`, `IReviewRepository`.
* Query via **Specification pattern** (e.g., `ProductsByFiltersSpec`).

**Caching**

* Redis for product lists, product details, categories tree.
* Cache invalidation on writes via events.

---

## 6) Application Layer

**Services (Use-cases)**

* `CatalogService`: list/filter/paginate products, product details, categories/brands.
* `CartService`: create/get cart, add/update/remove item, merge anonymous → customer.
* `OrderService`: checkout, place order, apply promotion, calculate totals.
* `PaymentService`: create payment intent (Stripe), confirm, webhook handling.
* `AccountService`: register, login, manage addresses, tokens.
* `ReviewService`: add/update/remove review.
* `AdminService`: CRUD products, categories, brands, inventory movements.

**Validation** with FluentValidation on DTOs.

---

## 7) API Design (Minimal APIs or Controllers)

**Conventions**

* RESTful resource endpoints under `/api/v1/…`
* JSON, UTC times, RFC 7807 ProblemDetails for errors.
* Pagination: `pageNumber`, `pageSize`; Sorting: `sort`; Filtering by query params.

**Endpoints (selected)**

* **Auth & Account**: register, login, refresh, account info, addresses.
* **Catalog**: products list/detail, categories tree, brands, reviews.
* **Cart**: get cart, add/update/remove items.
* **Orders**: place order, list orders, order details.
* **Payments**: payment intent, webhook.
* **Admin**: CRUD products/categories, manage inventory.

---

## 8) Security & Identity

* ASP.NET Core Identity with JWT auth.
* Password hashing, email confirmation, lockout policy.
* **Roles:** Customer, Admin.
* Refresh tokens stored with rotation.
* Rate limiting on auth and product search endpoints.

---

## 9) Cross‑Cutting

* **Global Exception Handling** → ProblemDetails mapper.
* **Validation Pipeline**.
* **Logging** → Serilog.
* **Caching** → Redis.
* **Email** → SendGrid/SMTP service abstraction.

---

## 10) Environment & Configuration

* `appsettings.json` + environment-specific configs.
* **Required settings:**

  * `ConnectionStrings:Default`
  * `Jwt:Issuer`, `Jwt:Audience`, `Jwt:Key`
  * `Redis:Connection`
  * `Stripe:ApiKey`, `Stripe:WebhookSecret`
  * `Serilog` configuration

---

## 11) Build & Run

**Backend**

```
cd src/External/Api
dotnet ef database update --project ../Persistence
dotnet runDocker Compose (/deploy/docker-compose.yml)
```

```
```

---

## 12) Testing Strategy

* **Unit Tests** (Domain, Application): xUnit + FluentAssertions.
* **Integration Tests** (API): WebApplicationFactory, Testcontainers for SQL + Redis.
* **Contract Tests**: Verify DTOs/OpenAPI.
* **Load Tests**: k6 or JMeter.

---

## 13) Observability & Ops

* **Health Checks:** `/health`, `/health/ready`.
* **Metrics:** `/metrics` (Prometheus).
* **Dashboards:** Grafana + Loki/Seq for logs.

---

## 14) Coding Guidelines

* Naming: `PascalCase` for types, `camelCase` for locals.
* Controllers/Endpoints thin; logic in services.
* Use async/await everywhere.

---

## 15) Delivery Roadmap

1. Foundation: skeleton, DI, EF, Identity, JWT, Serilog.
2. Catalog: products/categories/brands APIs.
3. Cart: anonymous cart, cookie, add/update/remove.
4. Account: register/login/addresses.
5. Checkout: order placement, Stripe intent, webhooks.
6. Admin: product/category management, inventory.
7. Reviews & Wishlist.
8. Caching & Performance.

** To store Image we use ImageKit.Io service **

** for Auth we use JWT with refresh token with email verification **


/// my notes
* PK 
    User, Product, Category, Brand → int (كفاية).
    Order, Payment, Shipment → Guid (عشان IDs دي غالبًا بتيجي من بره أو محتاج تخزنها Unique).


* the relation configuration we put it in the entity configuration that has FK

* Billing Address:   عنوان الفواتير => الخاص بالدفع.
* Shipping Address:  عنوان الشحن => المنتج يتبعت عليه.

* the relation between order and address i am still can't get it right            
    one address has many orders: زي مثلا العميل عمل 3 طلبات مختلفة في 3 أيام، وكلهم استخدموا نفس العنوان للشحن 

* why i stored AddressTypeEnum as string in db and OrderStatus as int ?
    because AddressTypeEnum has only 2 values and they rarely change, so storing them as string is fine and makes the db more readable
    but OrderStatus has many values and might change in the future, so storing them as int is better for performance and flexibility

* to solve the problem of services.Configure<ImageKitOptions>(configuration.GetSection("ImageKit")); it tells u serivice does not have configure method 
    u just need to install Microsoft.Extensions.Options.ConfigurationExtensions package

* i used service manager just as wrapper used to collect all service in one place so u just inject one service in the controller 
    but still u need to register all services not just service manager

* for api documentation i used scalar

* We create ByteStore.PresentationLayer because:
    It separates controllers from the main API project.
    It forces controllers to depend only on service contracts (not database/infrastructure).
    It keeps the project clean, maintainable, and flexible for future (REST, gRPC, etc).
    👉 Main API = startup & config.
    👉 Presentation = controllers & HTTP entry point.

* Rules for Naming our routes
    Use nouns, not verbs, in your API URIs to represent resources (e.g., /api/companies, not /api/getCompanies).
    For dependent resources (like employees of a company), structure the URI hierarchically: /api/companies/{companyId}/employees.
    This clear naming convention ensures consistency and understandability before implementing specific "GET" requests.


* Handling Errors and exception
    Error → An expected problem, such as “User not found” or “Password is too short”.
        Best handled with the Result pattern, returning success or failure without breaking program flow.

    Exception → An unexpected problem, such as database crash, null reference, or invalid state.
        Handled with a Global Exception Handler (middleware) to log and return a consistent error response.

    Validation in FluentValidation → Even though invalid input is an expected problem, FluentValidation throws a ValidationException.
        That’s why we typically handle it inside the Global Exception Handler, so the API returns proper error messages.




// TODO:
    check onion arch
    Review allowed only if customer purchased the product.
    make email service
    Validate Dtos in all services 
    look for does i use Interfaces with services or not
    Golbal query filter for customer and appUser
